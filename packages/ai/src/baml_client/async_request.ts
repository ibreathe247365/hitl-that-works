/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ npm install @boundaryml/baml
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code

import type { Audio, BamlCtxManager, BamlRuntime, ClientRegistry, FunctionLog, Image, Pdf, Video } from
"@boundaryml/baml"
import { type HTTPRequest, toBamlError } from "@boundaryml/baml";
import type TypeBuilder from "./type_builder";
import type * as types from "./types";
import type {
	Await,
	Calculation,
	Check,
	Checked,
	ClarificationRequest,
	DoneForNow,
	IntentCalculate,
	IntentCommentOnIssue,
	IntentCreateTicket,
	IntentLinkIssues,
	IntentSearchGitHub,
	IntentUpdateGitHubIssue,
	NothingToDo,
} from "./types";

type TickReason = "Unknown";

type BamlCallOptions = {
	tb?: TypeBuilder;
	clientRegistry?: ClientRegistry;
	env?: Record<string, string | undefined>;
	onTick?: (reason: TickReason, log: FunctionLog | null) => void;
};

export class AsyncHttpRequest {
	constructor(
		private runtime: BamlRuntime,
		private ctxManager: BamlCtxManager,
	) {}

	async DetermineNextStep(
		thread: string,
		__baml_options__?: BamlCallOptions,
	): Promise<HTTPRequest> {
		try {
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			return await this.runtime.buildRequest(
				"DetermineNextStep",
				{
					thread: thread,
				},
				this.ctxManager.cloneContext(),
				__baml_options__?.tb?.__tb(),
				__baml_options__?.clientRegistry,
				false,
				env,
			);
		} catch (error) {
			throw toBamlError(error);
		}
	}

	async SquashResponseContext(
		thread: string,
		error: string,
		__baml_options__?: BamlCallOptions,
	): Promise<HTTPRequest> {
		try {
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			return await this.runtime.buildRequest(
				"SquashResponseContext",
				{
					thread: thread,
					error: error,
				},
				this.ctxManager.cloneContext(),
				__baml_options__?.tb?.__tb(),
				__baml_options__?.clientRegistry,
				false,
				env,
			);
		} catch (error) {
			throw toBamlError(error);
		}
	}
}

export class AsyncHttpStreamRequest {
	constructor(
		private runtime: BamlRuntime,
		private ctxManager: BamlCtxManager,
	) {}

	async DetermineNextStep(
		thread: string,
		__baml_options__?: BamlCallOptions,
	): Promise<HTTPRequest> {
		try {
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			return await this.runtime.buildRequest(
				"DetermineNextStep",
				{
					thread: thread,
				},
				this.ctxManager.cloneContext(),
				__baml_options__?.tb?.__tb(),
				__baml_options__?.clientRegistry,
				true,
				env,
			);
		} catch (error) {
			throw toBamlError(error);
		}
	}

	async SquashResponseContext(
		thread: string,
		error: string,
		__baml_options__?: BamlCallOptions,
	): Promise<HTTPRequest> {
		try {
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			return await this.runtime.buildRequest(
				"SquashResponseContext",
				{
					thread: thread,
					error: error,
				},
				this.ctxManager.cloneContext(),
				__baml_options__?.tb?.__tb(),
				__baml_options__?.clientRegistry,
				true,
				env,
			);
		} catch (error) {
			throw toBamlError(error);
		}
	}
}
