/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ npm install @boundaryml/baml
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code

import type { Audio, BamlCtxManager, BamlRuntime, ClientRegistry, FunctionLog,FunctionResult, 
HTTPRequest, Image, Pdf, Video } from "@boundaryml/baml"
import {
	BamlAbortError,
	BamlStream,
	Collector,
	toBamlError,
} from "@boundaryml/baml";
import { AsyncHttpRequest, AsyncHttpStreamRequest } from "./async_request";
import {
	DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_CTX,
	DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME,
} from "./globals";
import { LlmResponseParser, LlmStreamParser } from "./parser";
import type { partial_types } from "./partial_types";
import type TypeBuilder from "./type_builder";
import type * as types from "./types";
import type {
	Await,
	Calculation,
	Check,
	Checked,
	ClarificationRequest,
	DoneForNow,
	IntentCalculate,
	RecursivePartialNull as MovedRecursivePartialNull,
	NothingToDo,
} from "./types";

/**
 * @deprecated Use RecursivePartialNull from 'baml_client/types' instead.
 */
export type RecursivePartialNull<T> = MovedRecursivePartialNull<T>;

type TickReason = "Unknown";

type BamlCallOptions = {
	tb?: TypeBuilder;
	clientRegistry?: ClientRegistry;
	collector?: Collector | Collector[];
	env?: Record<string, string | undefined>;
	tags?: Record<string, string>;
	signal?: AbortSignal;
	onTick?: (reason: TickReason, log: FunctionLog | null) => void;
};

export class BamlAsyncClient {
	private runtime: BamlRuntime;
	private ctxManager: BamlCtxManager;
	private streamClient: BamlStreamClient;
	private httpRequest: AsyncHttpRequest;
	private httpStreamRequest: AsyncHttpStreamRequest;
	private llmResponseParser: LlmResponseParser;
	private llmStreamParser: LlmStreamParser;
	private bamlOptions: BamlCallOptions;

	constructor(
		runtime: BamlRuntime,
		ctxManager: BamlCtxManager,
		bamlOptions?: BamlCallOptions,
	) {
		this.runtime = runtime;
		this.ctxManager = ctxManager;
		this.streamClient = new BamlStreamClient(runtime, ctxManager, bamlOptions);
		this.httpRequest = new AsyncHttpRequest(runtime, ctxManager);
		this.httpStreamRequest = new AsyncHttpStreamRequest(runtime, ctxManager);
		this.llmResponseParser = new LlmResponseParser(runtime, ctxManager);
		this.llmStreamParser = new LlmStreamParser(runtime, ctxManager);
		this.bamlOptions = bamlOptions || {};
	}

	withOptions(bamlOptions: BamlCallOptions) {
		return new BamlAsyncClient(this.runtime, this.ctxManager, bamlOptions);
	}

	get stream() {
		return this.streamClient;
	}

	get request() {
		return this.httpRequest;
	}

	get streamRequest() {
		return this.httpStreamRequest;
	}

	get parse() {
		return this.llmResponseParser;
	}

	get parseStream() {
		return this.llmStreamParser;
	}

	async DetermineNextStep(
		thread: string,
		__baml_options__?: BamlCallOptions,
	): Promise<
		| types.ClarificationRequest
		| types.DoneForNow
		| types.IntentCalculate
		| types.NothingToDo
		| types.Await
	> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const signal = options.signal;

			if (signal?.aborted) {
				throw new BamlAbortError("Operation was aborted", signal.reason);
			}

			// Check if onTick is provided - route through streaming if so
			if (options.onTick) {
				const stream = this.stream.DetermineNextStep(thread, __baml_options__);

				return await stream.getFinalResponse();
			}

			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = await this.runtime.callFunction(
				"DetermineNextStep",
				{
					thread: thread,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				options.tags || {},
				env,
				signal,
			);
			return raw.parsed(false) as
				| types.ClarificationRequest
				| types.DoneForNow
				| types.IntentCalculate
				| types.NothingToDo
				| types.Await;
		} catch (error) {
			throw toBamlError(error);
		}
	}

	async PerformCalculation(
		expression: string,
		__baml_options__?: BamlCallOptions,
	): Promise<types.Calculation> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const signal = options.signal;

			if (signal?.aborted) {
				throw new BamlAbortError("Operation was aborted", signal.reason);
			}

			// Check if onTick is provided - route through streaming if so
			if (options.onTick) {
				const stream = this.stream.PerformCalculation(
					expression,
					__baml_options__,
				);

				return await stream.getFinalResponse();
			}

			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = await this.runtime.callFunction(
				"PerformCalculation",
				{
					expression: expression,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				options.tags || {},
				env,
				signal,
			);
			return raw.parsed(false) as types.Calculation;
		} catch (error) {
			throw toBamlError(error);
		}
	}

	async SquashResponseContext(
		thread: string,
		error: string,
		__baml_options__?: BamlCallOptions,
	): Promise<string> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const signal = options.signal;

			if (signal?.aborted) {
				throw new BamlAbortError("Operation was aborted", signal.reason);
			}

			// Check if onTick is provided - route through streaming if so
			if (options.onTick) {
				const stream = this.stream.SquashResponseContext(
					thread,
					error,
					__baml_options__,
				);

				return await stream.getFinalResponse();
			}

			const collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];
			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = await this.runtime.callFunction(
				"SquashResponseContext",
				{
					thread: thread,
					error: error,
				},
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				options.tags || {},
				env,
				signal,
			);
			return raw.parsed(false) as string;
		} catch (error) {
			throw toBamlError(error);
		}
	}
}

class BamlStreamClient {
	private runtime: BamlRuntime;
	private ctxManager: BamlCtxManager;
	private bamlOptions: BamlCallOptions;

	constructor(
		runtime: BamlRuntime,
		ctxManager: BamlCtxManager,
		bamlOptions?: BamlCallOptions,
	) {
		this.runtime = runtime;
		this.ctxManager = ctxManager;
		this.bamlOptions = bamlOptions || {};
	}

	DetermineNextStep(
		thread: string,
		__baml_options__?: BamlCallOptions,
	): BamlStream<
		| partial_types.ClarificationRequest
		| partial_types.DoneForNow
		| partial_types.IntentCalculate
		| partial_types.NothingToDo
		| partial_types.Await,
		| types.ClarificationRequest
		| types.DoneForNow
		| types.IntentCalculate
		| types.NothingToDo
		| types.Await
	> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const signal = options.signal;

			if (signal?.aborted) {
				throw new BamlAbortError("Operation was aborted", signal.reason);
			}

			let collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];

			let onTickWrapper: (() => void) | undefined;

			// Create collector and wrap onTick if provided
			if (options.onTick) {
				const tickCollector = new Collector("on-tick-collector");
				collector = [...collector, tickCollector];

				onTickWrapper = () => {
					const log = tickCollector.last;
					if (log) {
						try {
							options.onTick!("Unknown", log);
						} catch (error) {
							console.error(
								"Error in onTick callback for DetermineNextStep",
								error,
							);
						}
					}
				};
			}

			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = this.runtime.streamFunction(
				"DetermineNextStep",
				{
					thread: thread,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				options.tags || {},
				env,
				signal,
				onTickWrapper,
			);
			return new BamlStream<
				| partial_types.ClarificationRequest
				| partial_types.DoneForNow
				| partial_types.IntentCalculate
				| partial_types.NothingToDo
				| partial_types.Await,
				| types.ClarificationRequest
				| types.DoneForNow
				| types.IntentCalculate
				| types.NothingToDo
				| types.Await
			>(
				raw,
				(
					a,
				):
					| partial_types.ClarificationRequest
					| partial_types.DoneForNow
					| partial_types.IntentCalculate
					| partial_types.NothingToDo
					| partial_types.Await => a,
				(
					a,
				):
					| types.ClarificationRequest
					| types.DoneForNow
					| types.IntentCalculate
					| types.NothingToDo
					| types.Await => a,
				this.ctxManager.cloneContext(),
				options.signal,
			);
		} catch (error) {
			throw toBamlError(error);
		}
	}

	PerformCalculation(
		expression: string,
		__baml_options__?: BamlCallOptions,
	): BamlStream<partial_types.Calculation, types.Calculation> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const signal = options.signal;

			if (signal?.aborted) {
				throw new BamlAbortError("Operation was aborted", signal.reason);
			}

			let collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];

			let onTickWrapper: (() => void) | undefined;

			// Create collector and wrap onTick if provided
			if (options.onTick) {
				const tickCollector = new Collector("on-tick-collector");
				collector = [...collector, tickCollector];

				onTickWrapper = () => {
					const log = tickCollector.last;
					if (log) {
						try {
							options.onTick!("Unknown", log);
						} catch (error) {
							console.error(
								"Error in onTick callback for PerformCalculation",
								error,
							);
						}
					}
				};
			}

			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = this.runtime.streamFunction(
				"PerformCalculation",
				{
					expression: expression,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				options.tags || {},
				env,
				signal,
				onTickWrapper,
			);
			return new BamlStream<partial_types.Calculation, types.Calculation>(
				raw,
				(a): partial_types.Calculation => a,
				(a): types.Calculation => a,
				this.ctxManager.cloneContext(),
				options.signal,
			);
		} catch (error) {
			throw toBamlError(error);
		}
	}

	SquashResponseContext(
		thread: string,
		error: string,
		__baml_options__?: BamlCallOptions,
	): BamlStream<string, string> {
		try {
			const options = { ...this.bamlOptions, ...(__baml_options__ || {}) };
			const signal = options.signal;

			if (signal?.aborted) {
				throw new BamlAbortError("Operation was aborted", signal.reason);
			}

			let collector = options.collector
				? Array.isArray(options.collector)
					? options.collector
					: [options.collector]
				: [];

			let onTickWrapper: (() => void) | undefined;

			// Create collector and wrap onTick if provided
			if (options.onTick) {
				const tickCollector = new Collector("on-tick-collector");
				collector = [...collector, tickCollector];

				onTickWrapper = () => {
					const log = tickCollector.last;
					if (log) {
						try {
							options.onTick!("Unknown", log);
						} catch (error) {
							console.error(
								"Error in onTick callback for SquashResponseContext",
								error,
							);
						}
					}
				};
			}

			const rawEnv = __baml_options__?.env
				? { ...process.env, ...__baml_options__.env }
				: { ...process.env };
			const env: Record<string, string> = Object.fromEntries(
				Object.entries(rawEnv).filter(([_, value]) => value !== undefined) as [
					string,
					string,
				][],
			);
			const raw = this.runtime.streamFunction(
				"SquashResponseContext",
				{
					thread: thread,
					error: error,
				},
				undefined,
				this.ctxManager.cloneContext(),
				options.tb?.__tb(),
				options.clientRegistry,
				collector,
				options.tags || {},
				env,
				signal,
				onTickWrapper,
			);
			return new BamlStream<string, string>(
				raw,
				(a): string => a,
				(a): string => a,
				this.ctxManager.cloneContext(),
				options.signal,
			);
		} catch (error) {
			throw toBamlError(error);
		}
	}
}

export const b = new BamlAsyncClient(
	DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME,
	DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_CTX,
);
