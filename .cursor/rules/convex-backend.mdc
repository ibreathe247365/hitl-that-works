---
type: auto_attached
pattern: "packages/backend/**/*"
description: Convex backend development guidelines
---

# Convex Backend Guidelines

## Convex Best Practices
- **Schema First**: Define all data structures in `schema.ts`
- **Type Safety**: Use Convex's generated types
- **Reactive Queries**: Leverage Convex's real-time capabilities
- **Proper Error Handling**: Use Convex's error handling patterns

## File Organization
```
convex/
├── schema.ts          # Database schema
├── auth.ts           # Authentication configuration
├── auth.config.ts    # Auth setup
├── todos.ts          # Example queries/mutations
├── privateData.ts    # Private data access
└── http.ts          # HTTP endpoints
```

## Query Patterns
```typescript
// ✅ Good: Proper query with error handling
export const getTodos = query({
  args: { userId: v.id("users") },
  handler: async (ctx, args) => {
    const todos = await ctx.db
      .query("todos")
      .filter((q) => q.eq(q.field("userId"), args.userId))
      .collect()
    
    return todos
  },
})
```

## Mutation Patterns
```typescript
// ✅ Good: Proper mutation with validation
export const createTodo = mutation({
  args: {
    title: v.string(),
    userId: v.id("users"),
  },
  handler: async (ctx, args) => {
    const id = await ctx.db.insert("todos", {
      title: args.title,
      userId: args.userId,
      completed: false,
      createdAt: Date.now(),
    })
    
    return id
  },
})
```

## Authentication Integration
- Use Better Auth with Convex integration
- Implement proper user session handling
- Use `ctx.auth` for authentication checks
- Handle private data access correctly

## Error Handling
- Use proper Convex error types
- Implement validation with `v.*` validators
- Handle edge cases gracefully
- Log errors appropriately

## Performance Considerations
- Use proper indexing in schema
- Implement efficient queries
- Consider data pagination
- Optimize for real-time updates

## API Routes with Convex Integration

### When to Use API Routes vs Convex Functions
- **Use API Routes for**:
  - External webhook endpoints
  - Third-party service integrations
  - File uploads/downloads
  - Custom authentication flows
  - Public endpoints that don't need real-time updates
- **Use Convex Functions for**:
  - Database operations
  - Real-time data synchronization
  - Internal business logic
  - User-facing queries and mutations

### API Route Patterns with Convex

#### Webhook Endpoints
```typescript
// ✅ Good: Webhook that processes data and calls Convex
import { NextRequest, NextResponse } from 'next/server';
import { ConvexHttpClient } from 'convex/browser';
import { api } from '@/convex/_generated/api';

const convex = new ConvexHttpClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    // Process webhook data
    const processedData = {
      source: 'webhook',
      timestamp: Date.now(),
      data: body
    };
    
    // Call Convex mutation to store data
    const result = await convex.mutation(api.webhooks.processWebhook, {
      data: processedData
    });
    
    return NextResponse.json({ success: true, id: result });
  } catch (error) {
    console.error('Webhook error:', error);
    return NextResponse.json(
      { error: 'Failed to process webhook' },
      { status: 500 }
    );
  }
}
```

#### Authentication in API Routes
```typescript
// ✅ Good: API route with Convex auth integration
import { NextRequest, NextResponse } from 'next/server';
import { ConvexHttpClient } from 'convex/browser';
import { api } from '@/convex/_generated/api';

export async function GET(request: NextRequest) {
  try {
    // Get auth token from request
    const token = request.headers.get('authorization')?.replace('Bearer ', '');
    
    if (!token) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    
    // Create authenticated Convex client
    const convex = new ConvexHttpClient(process.env.NEXT_PUBLIC_CONVEX_URL!, {
      auth: token
    });
    
    // Call authenticated Convex query
    const data = await convex.query(api.users.getProfile);
    
    return NextResponse.json(data);
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch data' },
      { status: 500 }
    );
  }
}
```

### Convex Client Configuration in API Routes

#### Environment Variables
```typescript
// ✅ Good: Proper environment variable usage
const convexUrl = process.env.NEXT_PUBLIC_CONVEX_URL;
const convexKey = process.env.CONVEX_DEPLOY_KEY; // For server-side operations

if (!convexUrl) {
  throw new Error('NEXT_PUBLIC_CONVEX_URL is not set');
}
```

#### Client Initialization Patterns
```typescript
// ✅ Good: Reusable Convex client factory
function createConvexClient(authToken?: string) {
  const client = new ConvexHttpClient(process.env.NEXT_PUBLIC_CONVEX_URL!);
  
  if (authToken) {
    client.setAuth(authToken);
  }
  
  return client;
}

// Usage in API routes
export async function POST(request: NextRequest) {
  const convex = createConvexClient();
  // ... rest of the logic
}
```

### Error Handling in API Routes

#### Convex Error Handling
```typescript
// ✅ Good: Comprehensive error handling
export async function POST(request: NextRequest) {
  try {
    const convex = new ConvexHttpClient(process.env.NEXT_PUBLIC_CONVEX_URL!);
    const result = await convex.mutation(api.data.create, { data });
    
    return NextResponse.json({ success: true, data: result });
  } catch (error) {
    console.error('API route error:', error);
    
    // Handle specific Convex errors
    if (error instanceof ConvexError) {
      return NextResponse.json(
        { error: error.message },
        { status: 400 }
      );
    }
    
    // Handle network errors
    if (error instanceof Error && error.message.includes('network')) {
      return NextResponse.json(
        { error: 'Service temporarily unavailable' },
        { status: 503 }
      );
    }
    
    // Generic error fallback
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

### Data Validation Patterns

#### Input Validation
```typescript
// ✅ Good: Validate input before calling Convex
import { z } from 'zod';

const webhookSchema = z.object({
  event: z.string(),
  data: z.record(z.any()),
  timestamp: z.number()
});

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    // Validate input
    const validatedData = webhookSchema.parse(body);
    
    // Call Convex with validated data
    const convex = new ConvexHttpClient(process.env.NEXT_PUBLIC_CONVEX_URL!);
    const result = await convex.mutation(api.webhooks.process, validatedData);
    
    return NextResponse.json({ success: true, id: result });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid input data', details: error.errors },
        { status: 400 }
      );
    }
    // ... other error handling
  }
}
```

### Security Considerations

#### Rate Limiting
```typescript
// ✅ Good: Implement rate limiting for API routes
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';

const ratelimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(10, '1 m'),
});

export async function POST(request: NextRequest) {
  const ip = request.ip ?? '127.0.0.1';
  const { success } = await ratelimit.limit(ip);
  
  if (!success) {
    return NextResponse.json(
      { error: 'Rate limit exceeded' },
      { status: 429 }
    );
  }
  
  // ... rest of the logic
}
```

#### CORS Configuration
```typescript
// ✅ Good: Proper CORS handling for API routes
export async function OPTIONS(request: NextRequest) {
  return new NextResponse(null, {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': process.env.ALLOWED_ORIGINS || '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    },
  });
}
```

### Best Practices for API Routes with Convex

1. **Always validate input** before calling Convex functions
2. **Use proper error handling** with specific error types
3. **Implement rate limiting** for public endpoints
4. **Log requests** for debugging and monitoring
5. **Use environment variables** for configuration
6. **Handle authentication** properly when needed
7. **Return consistent response formats**
8. **Implement proper CORS** for cross-origin requests
9. **Use TypeScript** for type safety
10. **Test webhook endpoints** with proper payloads